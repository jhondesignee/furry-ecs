class t{EID;static nextEID=0;static recycledEID=new Set;constructor(){this.EID=t.getNextEID()}static recycleEID(t){this.recycledEID.add(t)}static reset(){this.nextEID=0,this.recycledEID.clear()}static getNextEID(){if(this.recycledEID.size){const t=this.recycledEID.values().next().value;return t===this.nextEID&&this.nextEID++,this.recycledEID.delete(t),t}return this.nextEID++}}const e=1e3;var s,a;!function(t){t[t.NUMBER=0]="NUMBER",t[t.ARRAY=1]="ARRAY"}(s||(s={})),function(t){t[t.ADDED=0]="ADDED",t[t.ACTIVE=1]="ACTIVE",t[t.REMOVED=2]="REMOVED"}(a||(a={}));var r=Object.freeze({__proto__:null,get ComponentType(){return s},DEFAULT_ARRAY_SIZE:1e3,DEFAULT_WORLD_SIZE:e,get Status(){return a}});class n{hasChanged;data;deferredData;constructor(){this.data=new Map,this.deferredData={added:new Set,removed:new Set},this.hasChanged=!1}addData(t,e=!1){this.deferredData.removed.has(t)?this.deferredData.removed.delete(t):this.data.has(t)||this.deferredData.added.has(t)||(e?this.data.set(t,a.ACTIVE):this.deferredData.added.add(t))}removeData(t,e=!1){this.deferredData.added.has(t)?this.deferredData.added.delete(t):this.data.has(t)&&!this.deferredData.removed.has(t)&&(e?this.data.delete(t):this.deferredData.removed.add(t))}hasData(t){return this.data.has(t)}hasDeferredData(t){return this.deferredData.added.has(t)||this.deferredData.removed.has(t)}commitChanges(t=!1){this.hasChanged&&(this.hasChanged=!1),t&&this.applyDeferredChanges(),this.cleanPreviousChanges(),t||this.applyDeferredChanges()}destroy(){this.data.clear(),this.cleanDeferredChanges()}getDataStatus(t){return this.data.get(t)}keys(){return this.data.keys()}values(){return this.data.values()}length(){return this.data.size}*[Symbol.iterator](){for(const t of this.data)yield t}applyDeferredChanges(){for(const t of this.deferredData.added)this.data.set(t,a.ADDED),this.hasChanged=!0;for(const t of this.deferredData.removed)this.data.set(t,a.REMOVED),this.hasChanged=!0;this.cleanDeferredChanges()}cleanPreviousChanges(){for(const[t,e]of this.data)e===a.ADDED?this.data.set(t,a.ACTIVE):e===a.REMOVED&&this.data.delete(t)}cleanDeferredChanges(){this.deferredData.added.clear(),this.deferredData.removed.clear()}}class i{props;entities;constructor(t){this.props=i.createProperties(t||{}),this.entities=new n}static createProperties(t){return Object.fromEntries(Object.entries(t).map((([t,{type:a,length:r}])=>{switch(a){case s.NUMBER:return[t,new Array(e).fill(0)];case s.ARRAY:return r??=1e3,[t,Array.from({length:e},(()=>new Array(r).fill(0)))];default:return[t,null]}})))}}class o{start;update;destroy;constructor(t){this.start=t?.start,this.update=t?.update,this.destroy=t?.destroy}}class d{includeComponents;excludeComponents;entities;updated;constructor(t){this.includeComponents=new Set(t?.include||[]),this.excludeComponents=new Set(t?.exclude||[]),this.entities=new Map,this.updated=!1}exec(t,e){return this.updated=0!==this.entities.size&&!this.hasChanges(),this.updated?this.cleanChanges():this.entities=this.filterEntitiesByComponent(t),void 0!==e?this.filterEntitiesByStatus(e):new Array(...this.entities.keys())}hasChanges(){for(const t of[...this.includeComponents.keys(),...this.excludeComponents.keys()])if(t.entities.hasChanged)return!0;return!1}cleanChanges(){for(const[t,e]of this.entities)e===a.ADDED?this.entities.set(t,a.ACTIVE):e===a.REMOVED&&this.entities.delete(t)}filterEntitiesByComponent(t){const e=new Map;for(const s of this.includeComponents)if(t.components.hasData(s))for(const[t,a]of s.entities)e.set(t,a);for(const s of this.excludeComponents)if(t.components.hasData(s))for(const t of s.entities.keys())e.delete(t);return e}filterEntitiesByStatus(t){const e=new Array;for(const[s,a]of this.entities)a===t&&e.push(s);return e}}class h{entities;components;systems;constructor(){this.entities=new n,this.components=new n,this.systems=new n}get hasChanged(){return console.warn("Deprecation warning: 'this.hasChanged' is deprecated. Use 'this.entities.hasChanged' instead"),!1}addEntity(t){this.entities.addData(t)}addComponent(t,e){(this.entities.hasData(t)||this.entities.hasDeferredData(t))&&(e.entities.addData(t),this.components.addData(e))}addSystem(t){t.start?.(this),this.systems.addData(t)}removeEntity(t){for(const e of this.components.keys())(e.entities.hasData(t)||e.entities.hasDeferredData(t))&&this.removeComponent(t,e);(this.entities.hasData(t)||this.entities.hasDeferredData(t))&&this.entities.removeData(t)}removeComponent(t,e){(this.entities.hasData(t)||this.entities.hasDeferredData(t))&&(this.components.hasData(e)||this.components.hasDeferredData(e))&&e.entities.removeData(t)}removeSystem(t){t.destroy?.(this),this.systems.removeData(t)}update(t,e,s){this.applyChanges();for(const[r,n]of this.systems)n===a.ACTIVE&&r.update?.(this,t,e,s)}destroy(){this.entities.destroy(),this.components.destroy(),this.systems.destroy()}applyChanges(){this.entities.commitChanges(),this.components.commitChanges();for(const t of this.components.keys())t.entities.commitChanges(),0===t.entities.length()?this.components.removeData(t,!0):this.components.addData(t,!0);this.systems.commitChanges()}}class c{static ComponentType=s;static Status=a;static createWorld(){return new h}static createEntity(){return new t}static defineComponent(t){return new i(t)}static defineSystem(t){return new o(t)}static defineQuery(t){return new d(t)}static addEntity(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e];for(const t of s)for(const e of a)t.addEntity(e)}static addComponent(t,e,s){const a=Array.isArray(t)?t:[t],r=Array.isArray(e)?e:[e],n=Array.isArray(s)?s:[s];for(const t of a)for(const e of r)for(const s of n)t.addComponent(e,s)}static addSystem(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e];for(const t of s)for(const e of a)t.addSystem(e)}static removeEntity(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e];for(const t of s)for(const e of a)t.removeEntity(e)}static removeComponent(t,e,s){const a=Array.isArray(t)?t:[t],r=Array.isArray(e)?e:[e],n=Array.isArray(s)?s:[s];for(const t of a)for(const e of r)for(const s of n)t.removeComponent(e,s)}static removeSystem(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e];for(const t of s)for(const e of a)t.removeSystem(e)}static update(t,e,s,...a){const r=Array.isArray(t)?t:[t];for(const t of r)t.update(e,s,a)}static destroyWorld(t){const e=Array.isArray(t)?t:[t];for(const t of e)t.destroy()}}export{i as Component,r as Constants,t as Entity,d as Query,n as Storage,o as System,h as World,c as default};
