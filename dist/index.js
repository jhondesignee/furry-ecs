class e{EID;static nextEID=0;static recycledEID=new Set;constructor(){this.EID=e.getNextEID()}static recycleEID(e){this.recycledEID.add(e)}static reset(){this.nextEID=0,this.recycledEID.clear()}static getNextEID(){if(this.recycledEID.size){const e=this.recycledEID.values().next().value;return e===this.nextEID&&this.nextEID++,this.recycledEID.delete(e),e}return this.nextEID++}}var t,s;!function(e){e[e.NUMBER=0]="NUMBER",e[e.ARRAY=1]="ARRAY"}(t||(t={})),function(e){e[e.ADDED=0]="ADDED",e[e.ACTIVE=1]="ACTIVE",e[e.REMOVED=2]="REMOVED"}(s||(s={}));var n=Object.freeze({__proto__:null,get ComponentType(){return t},get QueryModifier(){return s}});class o{props;constructor(e){this.props=o.createProperties(e)}static createProperties(e){return Object.fromEntries(Object.entries(e).map((([e,s])=>{switch(s){case t.NUMBER:case t.ARRAY:return[e,{}]}})))}}class r{onStart;constructor(e){this.onStart=e}}class i{includeComponents;excludeComponents;entities;updated;constructor(e){this.includeComponents=new Set(e.include),this.excludeComponents=new Set(e.exclude),this.entities=new Map,this.updated=!1}exec(e,t){if(e.hasChanged)this.entities=this.filterEntitiesByComponent(e),this.updated=!1;else if(!this.updated){for(const[e,t]of this.entities)t===s.ADDED?this.entities.set(e,s.ACTIVE):t===s.REMOVED&&this.entities.delete(e);this.updated=!0}return void 0!==t?this.filterEntitiesByModifier(t):new Array(...this.entities.keys())}filterEntitiesByComponent(e){const t=new Map;for(const s of this.includeComponents)if(e.components.has(s)){const n=e.components.get(s);for(const[e,s]of n)t.set(e,s)}for(const s of this.excludeComponents)if(e.components.has(s)){const n=e.components.get(s);for(const e of n.keys())t.delete(e)}return t}filterEntitiesByModifier(e){const t=new Array;for(const[s,n]of this.entities)n===e&&t.push(s);return t}}class a{entities;components;systems;hasChanged;deferredChanges;constructor(){this.entities=new Map,this.components=new Map,this.systems=new Map,this.hasChanged=!1,this.deferredChanges={added:{entities:new Map,components:new Map,systems:new Map},removed:{entities:new Map,components:new Map,systems:new Map}}}addEntity(e){this.deferredChanges.added.entities.set(e,s.ADDED)}addComponent(e,t){if(this.entities.has(e)||this.deferredChanges.added.entities.has(e)){const n=new Map([...this.components.get(t)||[],...this.deferredChanges.added.components.get(t)||[]]);n.set(e,s.ADDED),this.deferredChanges.added.components.set(t,n)}}addSystem(e,t){this.deferredChanges.added.systems.set(e,e.onStart(this,t))}removeEntity(e){for(let[t,s]of this.components)s.has(e)&&this.removeComponent(e,t);for(let t of this.deferredChanges.added.components.values())t.has(e)&&t.delete(e);this.deferredChanges.added.entities.has(e)?this.deferredChanges.added.entities.delete(e):this.entities.has(e)&&this.deferredChanges.removed.entities.set(e,s.REMOVED)}removeComponent(e,t){if((this.entities.has(e)||this.deferredChanges.added.entities.has(e))&&(this.components.has(t)||this.deferredChanges.added.components.has(t))){const n=new Map([...this.components.get(t)||[],...this.deferredChanges.added.components.get(t)||[],...this.deferredChanges.removed.components.get(t)||[]]);this.deferredChanges.added.components.get(t)?.has(e)&&(n.delete(e),this.deferredChanges.added.components.set(t,n)),n.has(e)&&n.set(e,s.REMOVED),this.deferredChanges.removed.components.set(t,n)}}removeSystem(e){if(this.deferredChanges.added.systems.has(e))this.deferredChanges.added.systems.delete(e);else if(this.systems.has(e)){const t=this.systems.get(e);this.deferredChanges.removed.systems.set(e,t)}}update(e,t){this.hasChanged&&this.cleanChanges();for(let s of this.systems.values())s?.(e,t);this.hasChanged=!1,this.applyDeferredChanges(),this.deleteDeferredChanges()}destroy(){this.entities.clear(),this.components.clear(),this.systems.clear(),this.deleteDeferredChanges()}applyDeferredChanges(){const{entities:e,components:t,systems:s}=this.deferredChanges.added,{entities:n,components:o,systems:r}=this.deferredChanges.removed;for(const[t,s]of e)this.entities.set(t,s),this.hasChanged=!0;for(const[e,s]of t){const t=this.components.get(e);if(t)for(const[e,n]of t)s.set(e,s.get(e)||n);s.size&&this.components.set(e,s),this.hasChanged=!0}for(const[e,t]of s)this.systems.set(e,t),this.hasChanged=!0;for(const[e,t]of n)this.entities.set(e,t),this.hasChanged=!0;for(const[e,t]of o){const s=this.components.get(e);if(s)for(const[e,n]of s)t.set(e,t.get(e)||n);t.size&&this.components.set(e,t),this.hasChanged=!0}for(const e of r.keys())this.systems.delete(e),this.hasChanged=!0}cleanChanges(){for(const[e,t]of this.entities)t===s.ADDED?this.entities.set(e,s.ACTIVE):t===s.REMOVED&&this.entities.delete(e);for(const[e,t]of this.components){for(const[e,n]of t)n===s.ADDED?t.set(e,s.ACTIVE):n===s.REMOVED&&t.delete(e);0===t.size&&this.components.delete(e)}}deleteDeferredChanges(){for(const e of Object.values(this.deferredChanges))e.entities.clear(),e.components.clear(),e.systems.clear()}}class d{static ComponentType=t;static QueryModifier=s;static createWorld(){return new a}static createEntity(){return new e}static defineComponent(e){return new o(e)}static defineSystem(e){return new r(e)}static defineQuery(e){return new i(e)}static addEntity(e,t){const s=Array.isArray(e)?e:[e],n=Array.isArray(t)?t:[t];for(const e of s)for(const t of n)e.addEntity(t)}static addComponent(e,t,s){const n=Array.isArray(e)?e:[e],o=Array.isArray(t)?t:[t],r=Array.isArray(s)?s:[s];for(const e of n)for(const t of o)for(const s of r)e.addComponent(t,s)}static addSystem(e,t,...s){const n=Array.isArray(e)?e:[e],o=Array.isArray(t)?t:[t];for(const e of n)for(const t of o)e.addSystem(t,s)}static removeEntity(e,t){const s=Array.isArray(e)?e:[e],n=Array.isArray(t)?t:[t];for(const e of s)for(const t of n)e.removeEntity(t)}static removeComponent(e,t,s){const n=Array.isArray(e)?e:[e],o=Array.isArray(t)?t:[t],r=Array.isArray(s)?s:[s];for(const e of n)for(const t of o)for(const s of r)e.removeComponent(t,s)}static removeSystem(e,t){const s=Array.isArray(e)?e:[e],n=Array.isArray(t)?t:[t];for(const e of s)for(const t of n)e.removeSystem(t)}static update(e,t,s){const n=Array.isArray(e)?e:[e];for(const e of n)e.update(t,s)}static destroyWorld(e){const t=Array.isArray(e)?e:[e];for(const e of t)e.destroy()}}export{o as Component,n as Constants,e as Entity,i as Query,r as System,a as World,d as default};
