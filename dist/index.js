class t{EID;static nextEID=0;static recycledEID=new Set;constructor(){this.EID=t.getNextEID()}static recycleEID(t){this.recycledEID.add(t)}static reset(){this.nextEID=0,this.recycledEID.clear()}static getNextEID(){if(this.recycledEID.size){const t=this.recycledEID.values().next().value;return t===this.nextEID&&this.nextEID++,this.recycledEID.delete(t),t}return this.nextEID++}}const e=1e3,s=1e3;var a,r;!function(t){t[t.NUMBER=0]="NUMBER",t[t.ARRAY=1]="ARRAY"}(a||(a={})),function(t){t[t.ADDED=0]="ADDED",t[t.ACTIVE=1]="ACTIVE",t[t.REMOVED=2]="REMOVED"}(r||(r={}));var n=Object.freeze({__proto__:null,get ComponentType(){return a},DEFAULT_ARRAY_SIZE:s,DEFAULT_WORLD_SIZE:e,get Status(){return r}});class i{hasChanged;data;deferredData;constructor(){this.data=new Map,this.deferredData={added:new Set,removed:new Set},this.hasChanged=!1}addData(t,e=!1){return this.deferredData.removed.has(t)?(this.deferredData.removed.delete(t),!0):!this.data.has(t)&&!this.deferredData.added.has(t)&&(e?this.data.set(t,r.ACTIVE):this.deferredData.added.add(t),!0)}removeData(t,e=!1){return this.deferredData.added.has(t)?(this.deferredData.added.delete(t),!0):!(!this.data.has(t)||this.deferredData.removed.has(t))&&(e?this.data.delete(t):this.deferredData.removed.add(t),!0)}hasData(t){return this.data.has(t)}hasDeferredData(t){return this.deferredData.added.has(t)||this.deferredData.removed.has(t)}commitChanges(t=!1){this.hasChanged&&(this.hasChanged=!1),t&&this.applyDeferredChanges(),this.cleanPreviousChanges(),t||this.applyDeferredChanges()}destroy(){this.data.clear(),this.cleanDeferredChanges()}getDataStatus(t){return this.data.get(t)}keys(){return this.data.keys()}values(){return this.data.values()}length(t){return this.data.size+(t?this.deferredData.added.size:0)}serialize(){return{data:this.data,deferredData:this.deferredData,hasChanged:this.hasChanged}}deserialize(t){const{data:e,deferredData:s,hasChanged:a}=t;if(!(e instanceof Map))return!1;if(!(s?.added instanceof Set))return!1;if(!(s?.removed instanceof Set))return!1;if("boolean"!=typeof a)return!1;for(const t of e)this.data.set(t[0],t[1]);for(const t of s.added)this.deferredData.added.add(t);for(const t of s.removed)this.deferredData.removed.add(t);return this.hasChanged=a,!0}*[Symbol.iterator](){for(const t of this.data)yield t}applyDeferredChanges(){for(const t of this.deferredData.added)this.data.set(t,r.ADDED),this.hasChanged=!0;for(const t of this.deferredData.removed)this.data.set(t,r.REMOVED),this.hasChanged=!0;this.cleanDeferredChanges()}cleanPreviousChanges(){for(const[t,e]of this.data)e===r.ADDED?this.data.set(t,r.ACTIVE):e===r.REMOVED&&this.data.delete(t)}cleanDeferredChanges(){this.deferredData.added.clear(),this.deferredData.removed.clear()}}class o{props;entities;size;constructor(t,s){let a;this.size=s||e,t??={};for(const e of Object.values(t))if("object"!=typeof e){a=this.resolveDeprecatedSchema(t);break}this.props=this.createProperties(a||t),this.entities=new i}attachEntity(t){return!(this.entities.length(!0)>=this.size)&&this.entities.addData(t)}detachEntity(t){return this.entities.removeData(t)}createProperties(t){return Object.fromEntries(Object.entries(t).map((([t,{type:e,length:r}])=>{switch(e){case a.NUMBER:return[t,new Array(this.size).fill(0)];case a.ARRAY:return r??=s,[t,Array.from({length:this.size},(()=>new Array(r).fill(0)))];default:return[t,null]}})))}resolveDeprecatedSchema(t){let e={};for(const[r,n]of Object.entries(t))n===a.NUMBER?e[r]={type:n}:n===a.ARRAY?e[r]={type:n,length:s}:e[r]={type:n};return e}}class d{start;update;destroy;constructor(t){
/* istanbul ignore if -- @preserve */
"function"==typeof t?console.warn("Deprecation warning: config cannot be used as a function"):(this.start=t?.start,this.update=t?.update,this.destroy=t?.destroy)}}class h{includeComponents;excludeComponents;entities;updated;constructor(t){this.includeComponents=new Set(t?.include||[]),this.excludeComponents=new Set(t?.exclude||[]),this.entities=new Map,this.updated=!1}exec(t,e){return this.updated=0!==this.entities.size&&!this.hasChanges(),this.updated?this.cleanChanges():this.entities=this.filterEntitiesByComponent(t),void 0!==e?this.filterEntitiesByStatus(e):new Array(...this.entities.keys())}hasChanges(){for(const t of[...this.includeComponents.keys(),...this.excludeComponents.keys()])if(t.entities.hasChanged)return!0;return!1}cleanChanges(){for(const[t,e]of this.entities)e===r.ADDED?this.entities.set(t,r.ACTIVE):e===r.REMOVED&&this.entities.delete(t)}filterEntitiesByComponent(t){const e=new Map;for(const s of this.includeComponents)if(t.components.hasData(s))for(const[t,a]of s.entities)e.set(t,a);for(const s of this.excludeComponents)if(t.components.hasData(s))for(const t of s.entities.keys())e.delete(t);return e}filterEntitiesByStatus(t){const e=new Array;for(const[s,a]of this.entities)a===t&&e.push(s);return e}}class c{entities;components;systems;size;constructor(t){this.entities=new i,this.components=new i,this.systems=new i,this.size=t?.size||e}get hasChanged(){return console.warn("Deprecation warning: 'this.hasChanged' is deprecated. Use 'this.entities.hasChanged' instead"),!1}addEntity(t){return!(this.entities.length(!0)>=this.size)&&this.entities.addData(t)}addComponent(t,e){return!(this.components.length(!0)>=this.size)&&(!(!this.entities.hasData(t)&&!this.entities.hasDeferredData(t))&&(this.components.addData(e),e.attachEntity(t)))}addSystem(t){return!(this.systems.length(!0)>=this.size)&&(t.start?.(this),this.systems.addData(t))}removeEntity(t){for(const e of this.components.keys())(e.entities.hasData(t)||e.entities.hasDeferredData(t))&&this.removeComponent(t,e);return!(!this.entities.hasData(t)&&!this.entities.hasDeferredData(t))&&this.entities.removeData(t)}removeComponent(t,e){return!(!this.entities.hasData(t)&&!this.entities.hasDeferredData(t)||!this.components.hasData(e)&&!this.components.hasDeferredData(e))&&e.detachEntity(t)}removeSystem(t){return t.destroy?.(this),this.systems.removeData(t)}update(t,e,s){this.applyChanges();for(const[a,n]of this.systems)n===r.ACTIVE&&a.update?.(this,t,e,s)}destroy(){this.entities.destroy(),this.components.destroy(),this.systems.destroy()}applyChanges(){this.entities.commitChanges(),this.components.commitChanges();for(const t of this.components.keys())t.entities.commitChanges(),0===t.entities.length()&&this.components.removeData(t,!0);this.systems.commitChanges()}}class f{static ComponentType=a;static Status=r;static createWorld(){return new c}static createEntity(){return new t}static defineComponent(t,e){return new o(t,e)}static defineSystem(t){return new d(t)}static defineQuery(t){return new h(t)}static addEntity(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e],r=new Array;for(const t of s)for(const e of a)r.push(t.addEntity(e));return r}static addComponent(t,e,s){const a=Array.isArray(t)?t:[t],r=Array.isArray(e)?e:[e],n=Array.isArray(s)?s:[s],i=new Array;for(const t of a)for(const e of r)for(const s of n)i.push(t.addComponent(e,s));return i}static addSystem(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e],r=new Array;for(const t of s)for(const e of a)r.push(t.addSystem(e));return r}static removeEntity(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e],r=new Array;for(const t of s)for(const e of a)r.push(t.removeEntity(e));return r}static removeComponent(t,e,s){const a=Array.isArray(t)?t:[t],r=Array.isArray(e)?e:[e],n=Array.isArray(s)?s:[s],i=new Array;for(const t of a)for(const e of r)for(const s of n)i.push(t.removeComponent(e,s));return i}static removeSystem(t,e){const s=Array.isArray(t)?t:[t],a=Array.isArray(e)?e:[e],r=new Array;for(const t of s)for(const e of a)r.push(t.removeSystem(e));return r}static update(t,e,s,...a){const r=Array.isArray(t)?t:[t];for(const t of r)t.update(e,s,a)}static destroyWorld(t){const e=Array.isArray(t)?t:[t];for(const t of e)t.destroy()}}export{o as Component,n as Constants,f as ECS,t as Entity,h as Query,i as Storage,d as System,c as World,f as default};
